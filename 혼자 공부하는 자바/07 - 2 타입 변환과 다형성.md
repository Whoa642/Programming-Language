<b>다형성</b>은 다양한 객체를 사용해서 다양한 실행 결과가 나오도록 하는 성질이다. 다형성을 구현하려면 <b><i>메소드 재정의</i></b>와 <b><i>타입 변환</i></b>이 필수적이다.

<h3>자동 타입 변환</h3>

클래스의 타입 변환은 상속 관계에 있는 클래스 사이에서 발생하며 자식은 자동으로 부모 타입으로 변환된다. 
<b>즉 부모 타입 변수 = 자식 객체</b>(자식이 부모의 특징과 기능을 상속받기 때문에 부모와 동일하게 취급할 수 있다. 
<b>또한 바로 위의 부모가 아니더라도 자동 타입 변환이 발생할 수 있다.)</b>

<b>부모 타입으로 자동 변환되며 부모 클래스의 필드와 메소드만 사용할 수 있다.</b> <b><i>하지만 메소드가  자식 클래스에서 재정의되었으면 자식 클래스의 메소드가 대신 호출된다.</i></b>

```java
public class Parent{
 
    public void m1(){
        System.out.println("Parent-m1()");
    }
 
    public void m2(){
        System.out.println("Parent-m2()");
}
 
public class Child extends Parent{
    @Override
    public void m2(){
        System.out.println("Child-m2()");
    }
 
    public void m3(){
        System.out.println("Child-m3()");
    }
}
 
 
public class Main(){
    public static void main(String[] args){
        Child c = new Child();
 
        Parent p = c;
        p.m1();
        p.m2(); // 자식의 재정의된 메소드가 호출된다.
        // p.m3() 호출 할 수 없다.
}
```

<h3>필드의 다형성</h3>

필드의 타입을 부모 타입으로 선언하면 다양한 자식 객체를 저장할 수 있으며 이를 사용해서 필드 결과를 달리 할 수 있다. 

```java
public class Shape{
    int x,y;
 
    public void m(){
        System.out.println("기본 도형 입니다.");
}
 
public class Rectangle extends Shape{
    int width,height;
    
    @Override
    public void m(){
        System.out.println("직사각형 입니다.");
    }
}
 
public class Circle extends Shape{
    int radius;    
 
    @Override
    public void m(){
        System.out.println("원 입니다.");
    }
}
 
public class Square extends Shape{
    int len;
 
    @Override
    public void m(){
        System.out.println("정사각형 입니다.");
    }
}
 
public class Person{
    Shape l = new Rectangle();
    Shape r = new Circle();
    Shape t = new Square();
    Shape b = new Shape();
}
```

<h3>매개변수의 다형성</h3>

매개 변수에 부모 객체를 사용하고 인자로 자식 객체를 전달해서 다형성을 구현할 수 있다. <b>즉 전달되는 인자값에 따라서 메소드의 실행결과가 달라질 수 있다.</b>

```java
public class Shape{
    public void m(){
        System.out.println("모양이 없습니다.");
    }
}
 
public class Circle{
    @Override
    public void m(){ 
        System.out.println("원 입니다.");    
    }
}
 
public class Square{
    @Override
    public void m(){
        System.out.println("정사각형 입니다.");    
    }
}
 
public class Person{
    public void draw(Shape s){
        s.m();
    }
}
 
public class Main{
    public static void main(String[] args){
        Person p = new Person();
        Circle cir = new Circle(); 
        Square sq = new Square();
        
        p.draw(cir); // 자동 타입 변환 Shape s = cir;
         p.draw(sq); // 자동 타입 변환 Shape s = sq;
    }
}
```

<h3>강제 타입 변환</h3>

<b>강제 타입 변환</b>은 부모 타입을 자식 타입으로 변환하는 것을 의미한다. 
모든 부모 타입이 자식 타입으로 강제 변환할 수 있는 것은 아니며 <b><i>자식 타입이 부모 타입으로 자동 타입 변환한 후 다시 자식 타입으로 변환할 때 적용할 수 있다.</i></b> 
<b>즉 자식 타입 변수 = (자식 타입) 부모 객체</b>

하지만 개발자의 실수로 조건에 부합하지 않은 부모 타입을 자식 타입으로 변환하면 ClassCastException이 발생할 수 있다. 
<b>이를 방지하기 위해서 어떤 객체가 어떤 클래스의 인스턴스인지 확인하기 위해서 instanceof 연산자를 사용한다.</b>
instanceof 연산자는 좌항의 객체가 우항의 인스턴스이면 true를 반환하고 아니면 false를 반환한다.(<b>즉 좌항(객체) instance of 우항(타입)</b>) 메소드에서 강제 타입 변환이 필요할 경우 반드시 instanceof 연산자를 사용해야 한다.

```java
public class Parent{
}
 
public class Child extends Parent{
}
 
public class Main{
    public static void main(String[] args){    
        Parent p1 = new Child();
        m(p1);
 
        Parent p2 = new Parent();    
        m1(p2);
    }
 
    public static void m(Parent p){
        if(p instanceof Child){
            Child c = (Child)p;
            System.out.println("Child로 강제 타입 변환 성공");
        }else{
            System.out.println("Child로 강제 타입 변환 실패");
        }
    }
}
```
