<b>중첩 클래스</b>란 클래스 내부에 선언한 클래스를 말한다. 두 클래스의 멤버들을 서로 쉽게 접근할 수 있으며 외부에는 불필요한 관계를 감출 수 있다. 
<b>중첩 인터페이스</b>란 클래스 내부에 선언한 인터페이스를 말하며 해당 클래스와 관계를 맺는 구현 클래스를 만들기 위해서이다.

<h2>중첩 클래스</h2>

클래스 내부에 선언되는 위치에 따라서 두 가지로 분류하는데 <b>멤버 클래스</b>는 클래스의 멤버로서 선언되는 중첩 클래스이고 <b>지역 클래스</b>는 생성자 또는 메소드 내부에서 선언되는 중첩 클래스이다. 멤버 클래스는 클래스나 객체가 사용 중이면 재사용할 수 있지만 지역 클래스는 메소드를 실행하고 있을 때만 사용되면 메소드가 종료되면 사라진다.

<b>인스턴스 멤버 클래스</b>는 static 없이 선언된 클래스이며 <b>인스턴스 필드</b>와 <b>메소드</b>만 선언이 가능하고 정적 필드와 메소드는 선언할 수 없다.
<b>인스턴스 멤버 클래스를 외부에서 생성하려면 외부 클래스를 먼저 생성해야 한다</b>. 하지만 일반적으로 외부 클래스 내부에서 생성한다.

```java
public class Outer{
    
    // 인스턴스 멤버 클래스
    class Inner{
        Inner() {}    // 생성자
        int n;        // 인스턴스 필드
        void m() {}     // 인스턴스 메소드
        // static int n2; 정적 필드 -> X
        // static void m2() {} 정적 메소드 -> X
    } 
}
```

<b>정적 멤버 클래스</b>는 static 키워드로 선언된 클래스이며 모든 종류의 필드와 메소드를 선언할 수 있다. 
<b>인스턴스 멤버 클래스와 달리 클래스 외부에서 생성할 시 외부 클래스를 생성할 필요가 없다</b>.

```java
public class Outer{
    
    // 정적 멤버 클래스
    static class Inner{
        Inner() {}    // 생성자
        int n;        // 인스턴스 필드
        void m() {}     // 인스턴스 메소드
        static int n2; // 정적 필드
        static void m2() {} // 정적 메소드
    } 
}
```

<b>지역 클래스</b>는 메소드 내에서 선언되는 중첩 클래스이며 <b>접근 제한자와 static을 붙일 수 없다</b>. 
<b>지역 클래스 내부에서는 인스턴스 필드와 메소드만 선언할 수 있고 정적 필드와 메소드는 선언할 수 없다.</b> 
지역 클래스는 메소드가 실행될 때 메소드 내에서 객체를 생성하고 사용하기 때문에 비동기 처리를 위해 스레드 객체를 만들 때 사용한다.

```java
public void foo(){
    class Inner{
        Inner() {}
        int n;
        void m() {}
        // static int n2; -> X
        // static void m2() {} -> X
    }
}
```

<h2>중첩 클래스의 접근 제한</h2>

인스턴스 멤버 클래스는 외부 클래스의 인스턴스 필드의 초깃값이나 인스턴스 메소드에서 객체를 생성할 수 있으나 정적 필드의 초깃값이나 정적 메소드에서는 객체를 생성할 수 없다. 이와 반대로 정적 멤버 클래스는 모든 필드의 초깃값이나 모든 메소드에서 객체를 생성할 수 있다.

```java
public class Outer{
    // 인스턴스 필드
    InstanceC f1 = new InstanceC();
    StaticC f2 = new StaticC();
 
    // 인스턴스 메소드
    void m1(){
        InstanceC v1 = new InstanceC();
        StaticC v2 = new StaticC();
    }
    
    // 정적 필드
    // static InstanceC f3 = new InstanceC(); -> X
    static StaticC f4 = new StaticC();
 
    // 정적 메소드
    static void m2(){
        // InstanceC v1 = new InstanceC(); -> X
        StaticC v2 = new StaticC();
    }
 
    // 인스턴스 멤버 클래스
    class InstanceC {}
    // 정적 멤버 클래스
    static class StaticC {};
}
```

멤버 클래스가 인스턴스 또는 정적으로 선언됨에 따라서 멤버 클래스 내부에서 외부 클래스의 필드와 메소드에 접근할 때 제한이 따르는데 
<b>인스턴스 멤버 클래스 안에서는 외부 클래스의 모든 필드와 메소드에 접근할 수 있지만 정적 멤버 클래스의 경우 외부 클래스의 정적 필드와 메소드만 접근할 수 있다.</b>

```java
public class Outer{
    int f1;
    void m1() {}
 
    static int f2;
    static void m2() {}
 
    class InstanceC{
        void m(){
            // 모든 필드와 메소드에 접근 가능
            f1 = 100;
            m1();
    
            f2 = 100;
            m2();
        }
    }
 
    static class StaticC{
        void m(){        
            // f1 = 100;
            // m1();
            // 인스턴스 필드와 메소드는 접근 불가능
            f2 = 100;
            m2();
        }
    }
}
```


지역 클래스의 객체는 메소드 실행이 종료되면 사라지지만 계속 실행 상태로 존재할 수 있는데 이를 해결하기 위해서 컴파일 시 지역 클래스의 매개변수나 지역 변수의 값을 지역 클래스 내부에 복사한다. 
<b>이 값들이 변경되면 복사값과 달라지기 때문에 매개변수나 지역 변수를 final로 선언한다.</b>(자바 8부터는 final 키워드를 붙이지 않아도 final 특성을 가지고 있다.)

```java
public class Outer{
    public void m(int arg){
        int v = 100;
        
        // final이라서 수정 불가능
        // arg = 5;
        // v = 10;
        
        class Inner{
            int ret = arg-v;
        }
    }
}
```

중첩 클래스에서 this를 사용하면 외부 클래스가 아니라 중첩 클래스의 객체가 참조된다. 
따라서 중첩 클래스에서 외부 클래스의 객체 참조를 얻으려면 외부 클래스 이름을 this 앞에 붙여야 한다. 
<b>즉 외부 클래스.this.필드, 외부 클래스.this.메소드()</b>

```java
public class Outer{
    String f = "Outer field";
    void m(){
        System.out.println("Outer method");
    }
 
    class Inner{
        String f = "Inner field";
        void m(){
            System.out.println("Inner method");
        }    
    }
 
    void print(){
        // 중첩 객체
        System.out.println(this.f);
        this.m();
        
        // 외부 객체
        System.out.println(Outer.this.f);
        Outer.this.m();
    }
}
```

<h2>중첩 인터페이스</h2>
중첩 인터페이스도 중첩 클래스처럼 인스턴스 멤버 인터페이스와 정적 멤버 인터페이스 모두 가능하다. 
전자는 외부 클래스의 객체가 있어야 사용 가능하며 후자는 외부 클래스의 객체 없이 클래스만으로 바로 사용할 수 있다. 주로 정적 멤버 인터페이스를 많이 사용한다.
