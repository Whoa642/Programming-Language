<b>상속</b>은 중복되는 코드를 줄이기 위해서 사용한다. 자식 클래스에서 상속받을 부모 클래스를 결정하고 부모 클래스 이름 뒤에 <b>extends</b> 키워드를 사용한다.

```java
public class Shape {
    int x,y;
 
    Shape(int x, int y){
        this.x = x;
        this.y = y;
    }
 
    void print(){
        System.out.println("x 좌표:"+x+", y 좌표:"+y);
    }
 
}
 
// 부모 클래스 Shape를 상속받는 Circle 클래스
public class Circle extends Shape {
    int r;
 
    // 부모 클래스에서 상속받은 필드를 사용
    Circle(int x, int y, int r){
        this.x = x;
        this.y = y;
        this.r = r;
    }
 
    double calcArea(){
        return r*r*3.14;
    }
}
```

<h2>자바의 상속 특징</h2>
<ul>
  <li>다중 상속은 불가능하며 오직 1개의 부모 클래스만 상속받을 수 있다.</li>
  <li>부모 클래스에서 private 멤버는 상속되지 않는다. 부모 클래스와 자식 클래스가 같은 패키지에 있지 않다면  default 멤버는 상속 대상에서 제외된다.</li>
</ul>

<h2>부모 생성자</h2>
자식 객체 이전에 부모 객체가 먼저 생성되며 <b>부모 객체의 생성자는 자식 객체의 생성자의 맨 첫 줄에서 호출된다.</b>
부모의 생성자를 첫 줄에 명시적으로 선언하지 않으면 <b>super()</b>는 부모의 기본 생성자를 호출한다. 
하지만 만약 자식 생성자를 선언하고 명시적으로 부모 생성자를 호출하고 싶다면 매개변수의 개수와 자료형이 일치하는 부모 생성자를 super(매개변수)에 삽입한다. 
<b><i>super(매개변수)가 생략되면 super()가 컴파일러에 의해 자동으로 추가되기 때문에 부모의 기본 생성자가 존재해야 하며 반드시 자식 생성자 첫 줄에 위치해야 한다.</i></b>

```java
public class Shape {
    int x,y;
 
    Shape(int x, int y){
        this.x = x;
        this.y = y;
    }
 
    void print(){
        System.out.println("x 좌표:"+x+", y 좌표:"+y);
    }
 
}
 
public class Circle extends Shape {
    int r;
 
    Circle(int x, int y, int r){
        // 부모 생성자 호출
        super(x,y);
        this.r = r;
    }
 
    double calcArea(){
        return r*r*3.14;
    }
}
```

<h2>메소드 재정의</h2>

부모 클래스의 메소드를 자식 클래스에서 사용하기 적합하게 수정하는 것을 <b>메소드 재정의</b>라고한다. 메소드 재정의는 다음 3개의 규칙에 주의해야 한다.
<ol>
  <li>부모의 메소드와 동일한 시그너처를 가져야 한다.</li>
  <li>접근 제한을 더 강하게 할 수 없다.(부모 메소드가 public일 때 재정의하는 자식 메소드가 default나 private 접근 제한을 가질 수 없다는 의미이다.)</li>
  <li>새로운 예외(Exception)를 throws할 수 없다.</li>
</ol>

<b>메소드가 재정의되면 부모 객체의 메소드는 숨겨지기 때문에 자식 객체에서 메소드를 호출하면 재정의된 자식 메소드가 호출된다.</b>
하지만 부모 메소드를 호출하고 싶으면 명시적으로 <b>super()</b> 키워드를 사용한다. <b><i>즉 super.부모 메소드()</i></b>

```java
public class Shape {
    int x,y;
 
    Shape(int x, int y){
        this.x = x;
        this.y = y;
    }
 
    void print(){
        System.out.println("x 좌표:"+x+", y 좌표:"+y);
    }
 
}
 
public class Circle extends Shape {
    int r;
 
    Circle(int x, int y, int r){
        super(x,y);
        this.r = r;
    }
 
    @Override // 재정의된 메소드라고 컴파일러에게 알려준다.    
    void print(){
        System.out.println("x 좌표:"+x+", y 좌표:"+y+", 반지름 길이:"+r);
        // 명시적으로 부모 메소드를 호출한다.
        super.print();
    }
 
    double calcArea(){
        return r*r*3.14;
    }
}
```

클래스에 final을 붙이면 상속할 수 없는 클래스가 된다. <b>즉 final 클래스는 부모 클래스가 될 수 없기 때문에 자식 클래스를 만들 수 없다.</b>
메소드에 final을 붙이면 재정의할 수 없는 메소드가 된다. 
<b>즉 부모 클래스를 상속해서 자식 클래스를 선언할 때 부모 클래스에 선언된 final 메소드를 자식 클래스에서 재정의할 수 없다는 것이다.</b>

<h2>protected 접근 제한자</h2>

default와 같이 같은 패키지의 클래스에서 접근할 수 있으면 다른 패키지의 경우 상속 받은 자식 클래스만 접근할 수 있다.
```java
public class Shape{
    protected int x,y;
 
    protected Shape(){
    }
 
    public void m(){
    }
}
 
public class Triangle extends Shape{
    public Triangle(){
        super();
        this.x = this.y = 0;
        this.m();
    }
}
```
  
