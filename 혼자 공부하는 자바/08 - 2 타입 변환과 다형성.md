<b>인터페이스의 다형성</b>이란 프로그램 소스 코드의 변화 없이 구현 객체를 교체해서 프로그램의 실행 결과가 다양해지는 것을 의미한다.
(<b><i>상속이 같은 종류의 자식 클래스를 만드는 것이라면 인터페이스는 사용 방법이 동일한 클래스는 만드는 것이다</i></b>.)

<h3>자동 타입 변환</h3>
자동 타입 변환은 구현 객체가 인터페이스로 변환되는 것을 의미한다. 
즉 <b>인터페이스 변수 = 구현 객체(인터페이스 구현 클래스를 상속한 자식 클래스가 있다면 자식 객체 또한 인터페이스 타입으로 자동 타입 변환될 수 있다</b>.) 자동 타입 변환을 사용해서 필드의 다형성과 매개변수의 다형성을 구현할 수 있다.

<h3>필드의 다형성</h3>

필드를 인터페이스로 선언해서 다양한 구현 객체를 인터페이스 필드에 대입해서 필드 결과를 달리 할 수 있다. 

```java
public interface Shape{
    int x,y;
 
    public void m();
}
 
public class Rectangle implements Shape{
    int width,height;
    
    @Override
    public void m(){
        System.out.println("직사각형 입니다.");
    }
}
 
public class Circle implements Shape{
    int radius;    
 
    @Override
    public void m(){
        System.out.println("원 입니다.");
    }
}
 
public class Square implements Shape{
    int len;
 
    @Override
    public void m(){
        System.out.println("정사각형 입니다.");
    }
}
 
public class Person{
    Shape l = new Rectangle(); 
    Shape r = new Circle();
    Shape t = new Square();
 
    void print() {
        l.m();
        r.m();
        t.m();
    }
}
```

<h3>매개변수의 다형성</h3>

매개 변수에 인터페이스를 선언하고 인자로 구현 객체를 전달해서 다형성을 구현할 수 있다. <b>즉 전달되는 구현 객체에 따라서 메소드의 실행 결과가 달라질 수 있다.</b>

```java
public interface Shape{
    public void m(){
        System.out.println("모양이 없습니다.");
    }
}
 
public class Circle implements Shape{ 
    @Override
    public void m(){ 
        System.out.println("원 입니다.");    
    }
}
 
public class Square implements Shape{
    @Override
    public void m(){
        System.out.println("정사각형 입니다.");    
    }
}
 
public class Person{
    public void draw(Shape s){
        s.m();
    }
}
 
public class Main{
    public static void main(String[] args){
        Person p = new Person();
        Circle cir = new Circle(); 
        Square sq = new Square();
        
        p.draw(cir); // 자동 타입 변환 Shape s = cir;
        p.draw(sq); // 자동 타입 변환 Shape s = sq;
    }
}
```

<h3>강제 타입 변환</h3>

<b>강제 타입 변환</b>은 인터페이스를 구현 클래스 타입으로 변환하는 것을 의미한다. 
<b>즉 구현 클래스 변수 = (자식 타입) 부모 객체</b>, 하지만 개발자의 실수로 조건에 부합하지 않은 인터페이스를 구현 클래스 타입으로 변환하면 ClassCastException이 발생할 수 있다. 
<b>이를 방지하기 위해서 어떤 객체가 어떤 클래스의 인스턴스인지 확인하기 위해서 instanceof 연산자를 사용한다</b>. 
instanceof 연산자는 좌항의 객체가 우항의 인스턴스이면 true를 반환하고 아니면 false를 반환한다.(<b>즉 좌항(객체) instance of 우항(타입)</b>) 메소드에서 강제 타입 변환이 필요할 경우 반드시 instanceof 연산자를 사용해야 한다.

```java
public interface Interface{
}
 
public class Concrete implements Interface{
}
 
public class Main{
    public static void main(String[] args){    
         Interface itf = new Concrete();
 
        m(itf);
    }
 
    public static void m(Interface itfp){
        if(p instanceof Child){
            Concrete conc = (Concrete)itf;
            System.out.println("Concrete로 강제 타입 변환 성공");
        }else{
            System.out.println("Concrete로 강제 타입 변환 실패");
        }
    }
}
```

<h3>인터페이스 상속</h3>
인터페이스는 다른 인터페이스를 상속받을 수 있으며 클래스와 달리 <b>다중 상속</b>이 가능하다. 
<b><i>자식 인터페이스를 구현하는 구현 클래스는 자식 인터페이스와 부모 인터페이스의 모든 추상 메소드를 실체 메소드로 구현해야 한다.</i></b>
<b>사용 가능한 메소드에 대해서도 부모 인터페이스로 변환되면 하위 인터페이스에 선언된 메소드는 사용할 수 없다.</b>

```java
public interface Interface1{
    public void m1();
}
 
public interface Interface2{
    public void m2();
}
 
public interface Interface3 extends Interface1, Interface2{
    public void m3();
}
 
public class Concrete implements Interface3{
    public void m1(){
        System.out.println("Interface1 - m1()");
    }
 
    public void m2(){
        System.out.println("Interface2 - m2()");
    }
 
    public void m3(){
        System.out.println("Interface3 - m3()");
    }
}
 
public class Main{
    public static void main(String[] args){    
        Concrete c = new Concrete();
 
        Interface1 if1 = c;
        if1.m1(); // Interface1의 m1만 호출
        
        Interface2 if2 = c;
        if2.m2(); // Interface2의 m2만 호출
 
        Interface3 if3 = c;
        if3.m1(); 
        if3.m2();        
        if3.m3();        
    }
}
```
