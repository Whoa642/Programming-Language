제네릭 프로그래밍이란 하나의 참조 자료형이 아닌 여러 참조 자료형을 사용할 수 있도록 하는 프로그래밍을 말한다.(컴파일러가 자료형의 변환을 확인하기 때문에 안정적이다.)

Object 클래스로 제네릭을 구현할 수 있지만 원래 자료형으로 형 변환을 해야하기 때문에 번거롭다. 띠라서 이런 경우에 사용하는 프로그래밍 방식이 제네릭이다. 여러 참조 자료형을 쓸 수 있는 곳에 특정한 자료형을 지정하지 않고 클래스나 메서드를 정의한 후 사용하는 시점에 어떤 자료형을 사용할 것인지 지정한다.

제네릭에서는 여러 참조 자료형을 사용해야 하는 부분에 하나의 문자로 표현한다. 예를 들면 public class Generic<T>, 여기서 T를 자료형 매개변수이고 Generic<T>라고 정의하고 클래스를 사용할 때 T 위치에 실제 사용할 자료형을 지정한다. 자바 7부터는 제네릭 자료형의 클래스를 생성할 때 생성자에 자료형을 명시하지 않아도 된다.(선언된 자료형을 보고 생략된 부분을 컴파일러가 유추한다.) 참고로 T의 자료형이 정해지는 순간은 제네릭 클래스의 인스턴스가 생성되는 순간이다. 따라서 static 변수의 자료형이나 static 메서드 내부 변수의 자료형으로 T를 사용할 수 없는데 왜냐하면 static 변수, 메서드는 T의 자료형이 결정되는 시점보다 빠르기 때문이다.

T위치에 사용하는 자료형을 대입된 자료형이라고 하고 이 자료형을 대입해 만든 자료형을 제네릭 자료형이라고 한다.(e.g. Power:대입된 자료형, Generic<Powder>:제네릭 자료형) 제네릭 클래스를 사용하면 컴파일러는 일단 대입된 자료형이 쓰였는지 확인하고 class 파일을 생성할 때 T를 사용한 곳에 지정된 자료형에 따라 컴파일하기 때문에 형 변환이 필요없다. 제네릭을 사용하면 컴파일러가 자료형을 확인하기 때문에 안정적이고 형 변환 코드가 줄어든다.

제네릭 메서드는 메서드 선언부나 매개변수로 자료형 매개변수 T를 사용한 메서드를 말한다.(static 메서드에서도 활용 가능) 제네릭 클래스를 사용하는 경우 대입된 자료형으로 사용할 참조 자료형을 지정하는 것이 좋다.(하지 않을 경우 자료형을 알 수 없기 때문에 명시적 형 변환을 수행해야 한다.) 여러 자료형을 동시에 사용하려면 Object 클래스를 사용할 수 있다.

제네릭 클래스에서 T 자료형에 사용할 자료형에 제한을 둘 수 있다. extends 예약어를 사용한다. 즉 클래스 이름에 <T extends 상위 클래스> 명시해서 사용할 수 있는 자료형에 제한을 둔다.(T 위치에 특정 인터페이스를 구현한 클래스만 사용하려는 경우도 extends 예약어 사용)

만약 <T extends 상위 클래스>를 사용하지 않으면 T는 컴파일할 때 Object 클래스로 변환되기 때문에 Object 클래스가 기본으로 제공하는 메서드만 사용 가능하다.(자료형을 알 수 없기 때문이다.) 하지만 <T extends 상위 클래스>를 사용하면 컴파일할 때 내부적으로 T 자료형이 Object가 아닌 주어진 클래스로 변환된다.

제네릭 메서드의 일반 형식은 다음과 같은데 public <자료형 매개변수> 반환형 메서드 이름(자료형 매개변수 ...) {}, 자료형 매개변수는 여러 개일 수 있으며 이는 메서드 내에서만 유효하다.(이는 제네릭 클래스의 자료형 매개변수와 클래스 안에 있는 제네릭 매서드의 자료형 매개변수가 다르다는 의미) 또한 제네릭 클래스가 아니라도 내부에 제네릭 메서드를 구현할 수 있다. 

자바의 제네릭 자료형은 C++의 템플릿 클래스와 비슷하다.(클래스에서 사용할 자료형을 일반화해 놓고, 나중에 실제로 사용할 때 자료형을 지정한다.)

자료 구조는 프로그램 실행 중 메모리에 자료를 유지, 관리하기 위해 사용한다. 자바에서 자료 구조를 미리 구현하여 java.util 패키지에서 제공하는 것을 컬렉션 프레임워크라고 한다. 자바 컬렉션 프레임워크에는 여러 인터페이스가 정의되어 있고, 그 인터페이스를 구현할 클래스가 있다.

컬렉션 프레임워크 = Collection 인터페이스 + Map 인터페이스
Collection 인터페이스는 하나의 자료를 모아서 관리하는데 필요한 기능 제공하고 Map 인터페이스는 쌍으로 된 자료들을 관리하는데 유용한 기능을 제공한다.

Collection 인터페이스는 하위에 List 인터페이스와 Set 인터페이스가 있다. List 인터페이스를 구현한 클래스는 순차적인 자료를 관리하고 중복을 허용하는 클래스(ArrayList,Vector,LinkedList,Stack,Queue 등이 있다.) Set 인터페이스는 순서가 정해져 있지 않고 중복을 허용하지 않는다.(HashSet,TreeSet 등이 있다.) Map 인터페이스는 쌍으로 되어있는 자료를 관리하는 메서드가 있다.(key-value 쌍, key 값 중복 X, value는 중복 가능)

List 인터페이스는 객체를 순서에 따라 저장하고 유지하는데 필요한 메서드를 가진다.(대표적으로 배열) 자바에서 배열을 구현한 대표 클래스는 ArrayList,Vector가 있다.

ArrayList는 객체 배열을 구현한 클래스며 컬렉션 인터페이스와 하위 List 인터페이스를 구현한다. 객체 순서를 기반으로 순차적으로 자료를 관리하는 프로그램을 구현할 때 사용한다. ArrayList를 사용하려면 import java.util.ArrayList를 선언해야 한다. ArrayList() 디폴트 생성자 호출 시 배열 크기를 지정하지 않으면 크기가 10개짜리 배열이 기본으로 만들어진다.(이를 배열의 용량(capacity)이라고 한다. 초기에 배열의 용량 지정 가능)

ArrayList와 Vector 클래스
ArrayList와 Vector의 가장 큰 차이는 동기화 지원 여부(동기화란 두 개 이상의 스레드가 동시에 Vector를 사용할 때 오류가 나지 않도록 실행 순서를 보장하는 것) 스레드란 CPU의 작업 단위로서 프로그램이 메모리에서 수행되려면 스레드 작업이 생성되어야 한다. 하나의 스레드만 실행하는 경우 단일 스레드라고 부르고 2개 이상의 스레드를 실행할 경우 멀티 스레드라고 부른다.(같은 메모리 공간에 접근하기 때문에 변수 값,메모리 상태에 오류 발생 가능성이 있기 때문에 메모리에 동시에 접근하지 못하도록 순서를 맞추는 동기화를 실행한다.) 멀티 스레드 환경이 아닌 경우는 ArrayList를 사용한다.

동기화를 구현하기 위해서 동시에 작업이 이루어지는 자원에 대해 잠금(lock)을 수행하는데 메서드를 호출할 때 배열 객체에 잠금을 하고 메서드 수행이 끝나면 잠금을 해제한다. Vector의 모든 메서드는 호출 시 잠금과 해제가 일어나기 때문에 ArrayList보다 수행 속도가 느리다.

연결 리스트의 각 요소는 다음 요소를 가리키는 주소 값을 가진다.(따라서 물리적인 메모리는 떨어져 있어도 논리적으로 앞뒤 순서가 맞다.) ArrayList에 비해 중간에 자료를 삽입, 삭제하는데 시간이 적게 걸리고 크기를 동적으로 증가시킬 수 있다.

따라서 자료의 삽입, 삭제가 많은 경우는 연결 리스트를 사용하고 자료 변동이 거의 없는 경우에는 배열을 사용하는 것이 효율적이다.

순서가 없는 Set 인터페이스를 구현한 경우 클래스는 get(i) 메서드를 사용할 수 없다. 이 때 Iterator를 사용한다. Iterator는 Collection 인터페이스를 구현한 객체에서 정의되어 있는 iterator() 메서드를 호출하여 참조한다. Iterator를 사용하여 모든 요소를 순회할 때 2가지 메서드를 사용한다. boolean hasNext()는 이후에 요소가 더 있는지를 확인하는 메서드이고 요소가 있다면 true를 반환한다. E next()는 다음에 있는 요소를 반환한다.

HashSet 클래스는 집합 자료 구조이고 중복을 허용하지 않으며 자료가 추가된 순서와 상관없이 출력된다. 기본적으로 인스턴스 주소가 같으면 같은 객체이지만 중복을 허용하지 않으려면 논리적으로도 객체가 같아야 하기 때문에 equals(),hashCode() 메서드를 재정의 해야한다.

TreeSet 클래스
자바의 Collection,Map 인터페이스를 구현한 클래스 중 Tree 클래스는 데이터를 추가한 후 결과를 출력하면 결과 값이 정렬된다. TreeSet 클래스는 자료의 중복을 허용하지 않으면서 출력 결과 값을 정렬하는 클래스(이진 검색 트리를 사용해서 자료 정렬) 따라서 어떤 기준으로 비교할 것인지는 직접 구현해야 한다. 이 때 사용하는 인터페이스가 Comparable 또는 Comparator. 정렬 기준 값이 있는 클래스에 implements 예약어를 사용해서 구현한다.

Comparable 인터페이스에는 compareTo() 추상 메서드를 포함해야 하기 때문에 인터페이스를 구현하는 클래스에서 compareTo() 메서드를 구현해야 한다. compareTo()의 반환 값은 정수 값인데, 비교하는 두 값 중 this 값이 더 크면 양수를 반환하여 오름차순 정렬하고 그렇지 않고 this 값이 더 작으면 음수를 반환하여 내림차순 정렬한다. compareTo() 메서드처럼 프로그래머가 작성하지만 시스템이나 컬렉션 프레임워크가 호출하는 메서드를 콜백 메서드라고 한다.(프로그래머가 호출하는 메서드가 아니라 TreeSet에 요소를 추가할 때 호출되는 메서드)

Comparator도 정렬을 구현하는 데 사용하는 인터페이스이고 compare() 메서드를 구현해야 한다. 이 메서드는 매개변수가 2개로 compareTo() 메서드가 this와 전달된 매개변수를 비교한다면 compare() 메서드는 전달된 두 매개변수를 비교한다. 첫 번째 매개변수가 더 클 때 양수를 반환하여 오름차순으로 정렬한다. Comparator를 사용할 때 주의할 점은 TreeSet 생성자에 Comparator를 구현한 객체를 매개변수로 전달해야 한다는 것이다.(e.g. TreeSet<A> treeSet = new TreeSet<A>(new A());)

일반적으로 Comparator 인터페이스보다는 Comparable 인터페이스를 더 많이 사용한다.(다만 어떤 클래스가 이미 Comparable 인터페이스를 구현한 경우에는 이 클래스의 정렬 방식을 정의할 때 Comparator 인터페이스를 사용할 수 있다.) 예를 들어 String 클래스는 final 클래스라서 compareTo() 메서드를 정의할 수 없기 때문에 Comparator를 사용한다.

Map 인터페이스는 자료를 쌍(key-value)으로 관리하는데 필요한 메서드가 정의되어 있다.(객체의 key 값은 유일하고 value 값은 중복 가능) Map 인터페이스를 구현한 클래스는 내부적으로 해시 알고리즘에 의해 구현되어 있다.

HashMap은 Map 인터페이스를 구현한 클래스 중 가장 많이 사용한다.(HashMap에서 자료를 관리하는 방식은 해시 방식) 해시 방식의 자료를 저장하는 공간을 해시 테이블이라고 하고 key 값이 정해지면 이에 대한 해시 테이블의 저장 위치가 정해지는데 이런 위치를 계산하는 함수가 해시 함수이다. 해시 함수는 key 값에 index가 같아서 충돌이 발생할 수도 있고 key 값은 중복될 수 없으므로 equals(),hashcode() 메서드를 재정의해서 사용한다.

원소를 삽입할 때 put() 메서드를 사용해서 key-value 쌍을 삽입한다. 삭제할 경우 containsKey() 메서드를 호출하여 key 값이 HashMap에 존재하는지 확인하고 존재하면 key 값에 remove를 사용하여 삭제한다. Map 인터페이스는 모든 자료를 한 번에 순회할 수 있는 방법이 없기 때문에 모든 자료를 순회하려면 key 값을 먼저 가져와서 key 값에 해당하는 value 값을 찾아야 한다. 이를 위해서 keySet() 메서드를 호출하면 모든 key 값이 Set 객체로 반환된다. 반환된 Set 객체에 iterator() 메서드를 호출하면 key를 순회할 수 있는 Iterator가 반환된다. 그리고 모든 key 값을 순회하면서 get() 메서드에 key를 사용하여 해당 value 값을 가져온다. 아니면 values()메서드를 사용할 수 있다. 이 경우 모든 value 값을 Collection 자료형으로 반환해 준다.(key는 중복을 허용하지 않기 때문에 반환형이 Set, value는 중복을 허용하기 때문에 반환형이 Collection)

HashMap,Hashtable 클래스는 모두 쌍으로 이루어진 자료를 관리하는데 사용된다. Hashtable 클래스는 Vector 클래스처럼 멀티 스레드를 위한 동기화를 제공한다. Vector 클래스와 마찬가지로 멀티스레드 환경이 아니라면 Hashtable보다는 HashMap을 사용하는 것이 낫다.

TreeMap 클래스
TreeMap는 Map 인터페이스를 구현한 클래스 중 key 값으로 자료를 정렬한다. TreeSet과 마찬가지로 TreeMap은 이진 검색 트리로 구현하며 key 값으로 정렬해야 하기 때문에 key 값에 해당하는 Comparable나 Comparator 인터페이스를 구현해야 한다.

나 혼자 코딩! 
회원 이름순으로 정렬하기 위해서 compareTo() 메서드를 재정의하는 문제. String 클래스의 compareTo() 메서드를 사용한다.

```java
package collection;

public class Member implements Comparable<Member> {
	private int id;
	private String name;
	
	public Member(int id,String name) {
		this.id = id;
		this.name = name;
	}
	
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public boolean equals(Object obj) {
		if(obj instanceof Member) {
			Member member = (Member)obj;
			if(member.id == this.id) return true;
		}
		return false;
	}
	
	public int hashCode() {
		return id;
	}

	public String toString() {
		return name+" 회원님의 아이디는 "+id+"입니다";
	}
	
	public int compareTo(Member member) {
		return this.name.compareTo(member.name);
	}
}
```

기억을 되살리는 연습문제  
Q6:싱글톤 패턴에 HashMap을 적용하는 문제. 생각보다 어려웠다.
```java
package exercise6;
import java.util.HashMap;

public class CarFactory {
	private static CarFactory instance = new CarFactory();
	private CarFactory() {}
	private HashMap<String,Car> hashMap = new HashMap<>();
	
	public static CarFactory getInstance() {
		if(instance == null) {
			instance = new CarFactory();
		}
		return instance;
	}
	
	public Car createCar(String name) {
		if(hashMap.containsKey(name)) {
			return hashMap.get(name);
		}
		Car temp = new Car();
		hashMap.put(name, temp);
		return temp;
	}
}
```
