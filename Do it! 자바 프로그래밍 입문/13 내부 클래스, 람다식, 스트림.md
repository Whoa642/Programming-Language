내부 클래스는 클래스 내부에 선언한 클래스를 말한다. 내부 클래스는 선언 위치나 예약어에 따라 4가지 유형으로 나뉜다. 인스턴스 내부 클래스는 클래스 내부에 정의하고 정적 내부 클래스는 static 키워드를 사용하고 지역 내부 클래스는 메서드 내부에 정의한다.(이 3가지는 변수의 유형과 비슷하다.) 익명 내부 클래스는 클래스 이름 없이 선언하고 생성하여 사용할 수 있다.

인스턴스 내부 클래스는 인스턴스 변수를 선언할 때와 같은 위치에 선언하며 외부 클래스 내부에서만 생성하여 사용하는 객체를 선언할 때 쓴다. 다른 외부 클래스에서 사용할 일이 없는 경우 인스턴스 내부 클래스로 정의한다. 이 클래스는 외부 클래스 생성 후 생성된다.(따라서 외부 클래스를 먼저 생성하지 않고 인스턴스 내부 클래스를 사용할 수 없다.)

내부 클래스는 외부 클래스 안에 있기 때문에 외부 클래스에 private으로 선언된 변수도 사용할 수 있다. 클래스 생성과 상관없이 사용할 수 있는 정적 변수는 인스턴스 내부 클래스에 선언할 수 없다. 같은 이유로 정적 메서드도 선언할 수 없다.(인스턴스 내부 클래스는 외부 클래스 생성한 이후에 사용 가능하다.) 인스턴스 내부 클래스는 외부 클래스가 먼저 생성되어야 사용할 수 있다. 그리고 인스턴스 내부 클래스의 메서드는 외부 클래스의 메서드가 호출할 수 있다.

내부 클래스를 생성하는 이유는 선언된 외부 클래스에서만 사용하기 위해지만 외부 클래스 외의 다른 클래스에서 private이 아닌 내부 클래스를 생성하는 것이 문법적으로 가능하다. 하지만 내부 클래스를 private으로 선언하면 다른 클래스에서 이 클래스를 사용할 수 없다. 따라서 클래스 내부에서만 사용하려면 private으로 선언한다.

정적 내부 클래스
내부 클래스를내부 클래스는 클래스 내부에 선언한 클래스를 말한다. 내부 클래스는 선언 위치나 예약어에 따라 4가지 유형으로 나뉜다. 인스턴스 내부 클래스는 클래스 내부에 정의하고 정적 내부 클래스는 static 키워드를 사용하고 지역 내부 클래스는 메서드 내부에 정의한다.(이 3가지는 변수의 유형과 비슷하다.) 익명 내부 클래스는 클래스 이름 없이 선언하고 생성하여 사용할 수 있다.

인스턴스 내부 클래스는 인스턴스 변수를 선언할 때와 같은 위치에 선언하며 외부 클래스 내부에서만 생성하여 사용하는 객체를 선언할 때 쓴다. 다른 외부 클래스에서 사용할 일이 없는 경우 인스턴스 내부 클래스로 정의한다. 이 클래스는 외부 클래스 생성 후 생성된다.(따라서 외부 클래스를 먼저 생성하지 않고 인스턴스 내부 클래스를 사용할 수 없다.)

내부 클래스는 외부 클래스 안에 있기 때문에 외부 클래스에 private으로 선언된 변수도 사용할 수 있다. 클래스 생성과 상관없이 사용할 수 있는 정적 변수는 인스턴스 내부 클래스에 선언할 수 없다. 같은 이유로 정적 메서드도 선언할 수 없다.(인스턴스 내부 클래스는 외부 클래스 생성한 이후에 사용 가능하다.) 인스턴스 내부 클래스는 외부 클래스가 먼저 생성되어야 사용할 수 있다. 그리고 인스턴스 내부 클래스의 메서드는 외부 클래스의 메서드가 호출할 수 있다.

내부 클래스를 생성하는 이유는 선언된 외부 클래스에서만 사용하기 위해지만 외부 클래스 외의 다른 클래스에서 private이 아닌 내부 클래스를 생성하는 것이 문법적으로 가능하다. 하지만 내부 클래스를 private으로 선언하면 다른 클래스에서 이 클래스를 사용할 수 없다. 따라서 클래스 내부에서만 사용하려면 private으로 선언한다.

정적 내부 클래스
내부 클래스를 외부 클래스 생성과 무관하게 사용하고 정적 변수도 사용하고 싶을 경우 정적 내부 클래스를 사용한다. 정적 내부 클래스는 외부 클래스의 멤버 변수와 같은 위치에 정의하며 static 예약어를 함께 사용한다. 정적 내부 클래스는 외부 클래스의 인스턴스 변수를 사용 할 수 없다. 정적 내부 클래스에서 사용하는 메서드가 정적 메서드인 경우에는 외부 클래스와 정적 내부 클래스에 선언된 변수 중 정적 변수만 사용할 수 있다.

정적 내부 클래스는 외부 클래스를 생성하지 않고 내부 클래스 자료형으로 선언하여 생성 할 수 있다. 정적 내부 클래스에 선언한 메서드(정적 메서드 포함)나 변수는 private이 아닌 경우에 다른 클래스에서 사용 가능하다. 따라서 내부 클래스를 만들고 외부 클래스와 무관하게 다른 클래스에서도 사용하려면 정적 내부 클래스를 사용한다. 하지만 만약 정적 내부 클래스를 private으로 선언하면 다른 클래스에서 사용할 수 없다.

지역 내부 클래스는 메서드 내부에 클래스를 정의하여 사용하는 것을 의미한다. 따라서 이 클래스는 메서드 안에서만 사용 가능하다. Runnable 인터페이스는 자바에서 스레드를 만들 때 사용하는 인터페이스로 java.lang에 있으면 반드시 run() 메서드를 구현해야 한다. 지역 내부 클래스를 사용하려면 Runnable 인터페이스를 구현하고 지역 내부 클래스를 생성해서 반환한다. 지역 내부 클래스를 사용하려면 Runnuable를 반환하는 메서드를 사용해서 생성된 지역 내부 클래스를 반환한다. 지역 내부 클래스의 메서드에서 사용하는 지역 변수는 상수로 처리된다. 

익명 내부 클래스는 클래스 이름을 사용하지 않는 클래스이다. 익명 내부 클래스의 형식은 지역 내부 클래스의 마지막에 Runnable을 반환하는 return문을 클래스 이름 부분에 이름 없이 return new Runnable()을 적어서 인터페이스를 생성과 동시에 반환한다.(다른 내부 클래스와 달리 ;을 마지막에 붙인다.) 익명 내부 클래스를 한 개의 인터페이스나 추상 클래스를 바로 생성할 수 있는데 인터페이스는 인스턴스로 생성할 수 없다. Runnable 인터페이스를 생성하려면 인터페이스 몸체가 필요하다. 이 몸체에 run() 메서드를 구현한다. 익명 내부 클래스를 만드는 또 다른 방법은 익명 내부 클래스를 인터페이스나 추상 클래스 자료형으로 변수를 선언한 후 익명 내부 클래스를 생성해 대입한다.(이 역시 마지막에 ;을 붙인다.) 

익명 내부 클래스를 변수에 대입하거나 메서드 안에서 인터페이스나 추상 클래스를 구현해서 생성한다. 지역 변수는 지역 내부 클래스처럼 상수로 자동으로 변하기 때문에 메서드 호출이 끝나도 사용할 수 있다.

함수 구현과 호출만으로 프로그램을 만들 수 있는 프로그래밍 방식을 함수형 프로그램이라고 하는데 자바에서 함수형 프로그래밍 방식을 람다식이라 한다. 람다식은 이름이 없는 익명 함수를 만드는 것이다. 

람다식 문법은 다음과 같이 (매개변수)->{실행문;} 만약 두 개의 매개변수를 더하는 add함수를 람다식으로 구현하면 (int x,int y)->{return x+y;}. 추가적으로 몇 가지 문법 특징이 있는데 매개변수 자료형을 생략할 수 있으면 매개변수가 하나인 경우에는 괄호 생략도 할 수 있다.
하지만 2개 이상인 경우 괄호를 생략할 수 없다. 또, 중괄호 안의 구현 부분이 한 문장인 경우 중괄호를 생략할 수 있지만 구현 부분이 한 문장이더라도 return문은 중괄호를 생략할 수 없다. 마지막으로 중괄호 안의 구현 부분이 return문 하나라면 중괄호 return을 모두 생략하고 식만 쓴다.

람다식을 구현하려면 먼저 인터페이스를 만들고 인터페이스에 람다식으로 구현할 메서드를 선언하는데 이를 함수형 인터페이스라고 한다. 람다식은 하나의 메서드를 구현하여 인터페이스형 변수에 대입하기 때문에 인터페이스가 반드시 1개의 메서드만 가져야 한다. 하지만 만일의 경우를 위해서 @FunctionalInterface 애노테이션을 사용해야 한다. 이 애노테이션을 사용하면 함수형 인터페이스라는 의미고 메서드를 2개 이상 선언하면 오류가 발생한다.

익명 내부 클래스는 클래스 이름 없이 인터페이스 자료형 변수에 바로 메서드 구현부를 생성하여 대입할 수 있는데 람다식으로 메서드를 구현해서 호출하면 컴퓨터 내부에서는 익명 클래스가 생성되고 이를 통해 익명 객체가 생성된다. 따라서 람다식에서 사용하는 지역 변수를 수정하면 오류가 발생한다.(익명 내부 클래스가 생성되므로 외부 메서드의 지역 변수를 사용하면 변수는 상수가 된다.)
 
람다식을 이용하면 구현된 함수를 변수처럼 사용할 수 있다. 즉 함수의 구현부를 변수에 대입하고 매개변수로 전달하고 메서드의 반환 값으로 사용할 수 있다.

스트림은 여러 자료의 처리에 대한 기능을 구현해 놓은 클래스로 자료의 종류와 상관없이 같은 방식으로 메서드를 호출할 수 있다.(이를 자료를 추상화 했다고 말한다.)

스트림 연산의 중간,최종 연산 두 가지로 나누어진다. 전자는 자료를 거르거나 변경하여 다른 자료를 내부적으로 생성하고 후자는 생성된 내부 자료를 소모해 가면서 연산을 수행하기 때문에 마지막에 한 번만 호출한다. 중요한 점은 최종 연산이 호출되어야 중간 연산의 결과가 만들어진다는 것이다.

filter()는 조건을 넣고 그 조건에 맞는 참인 경우만 추출하는 경우에 사용하고 map()은 클래스가 가진 자료 중 이름만 출력하는 경우에 사용한다. 두 함수는 조건이나 함수에 맞는 결과를 추출해 내는 중간 역할을 한다. 최종 연산은 연산의 특성 때문에 수행된 후 해당 스트림은 더 이상 사용할 수 없다. 그래서 최종 연산은 결과를 만드는 데 주로 사용한다.(e.g. sum(),count())

스트림의 특성을 정리하면 다음과 같다.
1.자료의 대상과 관계없이 동일한 연산을 수행한다. 여러 자료 구조에 대해 작업을 일관성 있게 처리할 수 있는 메서드를 제공한다.

2.한 번 생성하고 사용한 스트림을 재사용할 수 없다. 스트림을 생성하고 이 스트림에 메서드를 호출하여 연산을 수행했다면 해당 스트림을 다른 연산에 사용할 수 없다. 소모된 요소는 재사용할 수 없다. 따라서 다른 기능을 호출하려면 스트림을 새로 생성해야 한다.

3.스트림의 연산은 기존 자료를 변경하지 않는다. 이는 스트림 연산을 위해 사용하는 메모리 공간이 별도로 존재하기 때문이다.

4.스트림의 연산은 중간 연산과 최종 연산이 있다. 중간 연산은 여러 개가 적용될 수 있지만 최종 연산은 맨 마지막에 한 번 적용된다. 중간 연산이 여러 개 호출되었더라도 최종 연산이 호출되어야 스트림의 중간 연산이 모두 적용된다.(중간 연산이 호출되어도 최종 연산이 호출되지 않으면 결과를 가져올 수 없다.) 이를 지연 연산(lazy evaluation)이라고 부른다.

reduce() 연산 부분은 아직 공부하지 않아서 생략했다. 기억을 되살리는 연습문제의 경우 스트림을 사용해서 풀어야 하는데 아직 익숙하지 않아서 못풀었다. 이 부분은 새롭게 배우는 내용이 많아서 복습을 자주 해야겠다.
