자바 프로그래밍에서 외부 패키지에 선언한 클래스를 사용할 때는 import문으로 클래스가 어느 패키지에 속해 있는지 선언해야 한다. 하지만 java.lang 패키지는 컴파일할 때 import java.lang; 문장이 자동으로 추가되기 때문에 import문이 필요없다. 

Object 클래스는 모든 자바 클래스의 최상위 클래스이고 나머지 모든 클래스는 Object 클래스로부터 상속을 받는다. 이는 기존 JDK에서 제공하는 클래스뿐만 아니라 직접 만드는 클래스도 포함된다. java.lang 패키지가 컴파일 할 때 import문이 자동으로 추가되는 것처럼 extends Object도 컴파일 과정에서 자동으로 추가된다. 

모든 클래스가 Object 클래스를 상속받았으므로 Object의 메서드를 사용할 수 있고, 재정의할 수도 있고, Object형으로 암시적 형 변환도 가능하다. 하지만 Object 클래스의 모든 메서드를 재정의할 수 있는 것은 아니다.(final 예약어로 선언한 메서드는 자바 가상 머신과 관련된 메서드이기 때문에 재정의할 수 없다.)

Object 클래스에서 제공하는 toString() 메서드는 객체 정보를 문자열로 바꾸어준다. Object 클래스를 상속받은 모든 클래스는 toString()을 재정의 할 수 있고 String과 같이 많은 JDK 클래스에는 이미 재정의 되어있다. 하지만 만든 클래스는 반드시 toString() 메서드를 직접 재정의 해야한다.(toString() 메서드의 원형은 생성된 인스턴스의 클래스 이름@주소 값(해시 코드 값)을 보여준다.)

equals() 메서드는 두 인스턴스의 주소 값을 비교하여 boolean 값(true/false)를 반환한다. 주소 값이 같다면 당연히 같은 인스턴스지만 서로 다른 주소 값을 가질 때도 같은 인스턴스라고 정의할 수 있는 경우가 있다. 따라서 인스턴스의 메모리 주소가 같을 때 뿐만 아니라 논리적으로 두 인스턴스가 같을 때도 equals() 메서드가 정확한 비교를 해야 하기 때문에 재정의가 필요하다.(equals() 메서드를 재정의할 때 매개변수는 Object 자료형이고 instanceof를 사용해서 매개변수의 원래 자료형을 확인한다.)

해시는 정보를 저장하고 검색 시 사용하는 자료 구조로 해시 함수는 객체의 키 값을 인자로 넣으면 객체가 저장되어야 할 위치나 해시 테이블 주소(위치)를 반환한다. 따라서 객체의 키 값을 알면 해당 객체의 위치를 빠르게 검색할 수 있다. 자바에서는 인스턴스를 힙 메모리에 생성하여 관리할 때 해시 알고리즘 사용한다.(참조 변수를 출력할 때 16진수 숫자값이 해시 코드 값이고 이 값은 자바 가상 머신이 힙 메모리에 저장한 인스턴스의 주소 값)

자바에서 두 인스턴스가 같다면 hashCode() 메서드에서 반환하는 해시 코드 값(인스턴스의 주소 값)이 같다. 하지만 논리적으로 같은 두 객체의 경우도 같은 해시 코드 값을 반환하도록 hashCode() 메서드 재정의 해야한다. 이는 equals() 메서드를 재정의했다면 hashCode() 메서드로 재정의해야 한다는 의미(hashCode() 메서드를 재정의할 때는 equals() 메서드에서 사용한 멤버 변수를 사용한다.) hashCode() 메서드를 재정의했을 때 인스턴스의 주소 값은 System.identityHashCode() 메서드를 사용하면 알 수 있다.

객체 원본을 두고 복사본을 사용하거나 기본 틀의 복사본을 사용해 동일한 인스턴스를 만들려고 할 경우에 clone() 메서드를 사용한다. clone() 메서드를 사용하려면 객체를 복제해도 된다는 의미로 클래스에 Cloneable 인터페이스를 구현해야 한다.(이를 명시하지 않을 경우 clone() 메서드 호출 시CloneNotSupportedException이 발생한다.) clone() 메서드는 클래스의 인스턴스를 새로 복제하여 생성한다.(즉 멤버 변수는 동일하지만 메모리가 다른 인스턴스를 생성한다. 그러면 깊은 복사인가?)

Cloneable 인터페이스는 선언해도 별도로 구현해야하는 메서드가 없는데 이렇게 구현할 메서드가 없는 인터페이스를 마커 인터페이스라고 한다.

String을 사용할 때 문자열을 생성자의 매개변수로 하여 생성하는 방식과 이미 생성된 문자열 상수를 가리키는 방식이 있다. 예를 들어, String s1 = new String("abc"), String s2 = "abc", 전자는 "abc" 문자열을 위한 메모리가 할당되고 새로운 객체가 생성되지만 후자는 기존에 있는 "abc"라는 문자열 상수의 메모리 주소를 가리킨다. (따라서 만약 String s3 = "abc"라고 하면 s2,s3의 주소 값은 같다. C의 배열 문자열 포인터 문자열 관계인 것 같다.) 참고로 "abc",10,1.5과 같이 상수값을 저장하는 공간을 상수 풀이라고 한다.

String 클래스는 final char[]로 구현을 하기 때문에 한 번 생성된 문자열은 변경되지 않는다. 즉 문자열은 불변한다. 이 2개의 클래스로 문자열을 연결하면 둘 중 하나의 문자열이 변경되는 것이 아니라 두 문자열이 연결되어 새로운 문자열이 생성된다.(이 또한 C의 문자열 리터럴과 같은 개념이다.) 따라서, String 클래스를 사용하여 문자열을 변경하는 코드를 작성하면 메모리가 많이 낭비된다.이 문제를 해결하는 것이 StringBuffer, StringBuilder 클래스다.

둘 다 내부에 변경 가능한(즉 final이 아닌) char[]를 변수로 가지고 있다. 이 두 클래스를 사용하여 문자열을 연결하면 사용하던 char[] 배열이 확장되므로 추가 메모리를 사용하지 않는다. 따라서 문자열을 연결하거나 변경할 시 두 클래스 중 하나를 선택한다.(차이는 여러 스레드가 동시에 문자열을 변경하려 할 때 문자열이 안전하게 변경되도록 보장해 주는가 그렇지 않은가의 차이)

StringBuffer 클래스는 문자열이 안전하게 변경되도록 보장하지만 StringBudiler 클래스는 보장되지 않는다.(스레드를 생성하는 멀티스레드 프로그램이 아니라면 StringBuilder를 사용하는 것이 실행 속도가 빠르다.) StringBuilder 클래스를 생성하고 여기에 문자열을 추가하면(append) 메서드가 실행될 때마다 메모리가 새로 생성되는 것이 아니라 하나의 메모리에 계속 연결된다.(즉 메모리 주소 값이 유지된다.)

Wrapper 클래스는 기본 자료형을 감쌌다는 의미를 가지는데 이는 기본 자료형의 객체를 제공하는 클래스라는 뜻이고 Wrapper 클래스의 사용법은 자료형마다 큰 차이가 없다.
책의 경우 예시 Wrapper 클래스로 Integer 클래스를 설명한다. Integer 클래스의 생성자는 정수,문자열을 매개변수로 받는 경우 2가지 있다. 즉 Integer(int value) or Integer(String s)), Integer 클래스 내부의 int 자료형 값을 가져오기 위해서 intValue() 메서드를 사용한다.
valueOf() 정적 메서드를 사용하면 생성자를 사용하지 않고 정수,문자열을 바로 Integer 클래스로 반환할 수 있다. parseInt() 메서드를 활용하면 문자열이 어떤 숫자를 나타낼 때, 문자열에서 int 값을 바로 가져와서 반환할 수 있다.

기본 자료형과 Wrapper 클래스는 같은 값을 나타내지만 쓰임과 특성이 전혀 다르기 때문에 자바 5이전에는 기본 자료형과 Wrapper 클래스 중 하나의 형태로 일치를 시켜야했다. 하지만 자바 5부터는 명시적으로 변환을 할 필요가 없다.기본형이 객체형으로 변환될 경우 오토방식이라고 하고 객체형을 기본형으로 변환할 때 언방식이라고 부른다. 이는 자바의 연산 방식은 그대로 유지되고 컴파일러가 변경하기 때문에 프로그램 작성 시 객체의 형 변환에 신경 쓸 필요가 없다.)

자바의 모든 클래스와 인터페이스는 컴파일되고 나면 class파일로 생성된다.(example.java -> example.class) 이 class 파일에는 클래스나 인터페이스에 대한 변수,메서드,생성자 등의 정보가 들어 있다. 따라서 Class 클래스는 컴파일된 class 파일에 저장된 클래스나 인터페이스 정보를 가져오는데 사용한다.(주로 모르는 클래스의 정보를 사용할 경우에 클래스 정보를 직접 찾아야 할 때 Class 클래스를 활용한다.)

Class 클래스를 선언하고 클래스 정보를 가져오는 방법은 3가지 
1. Object 클래스의 getClass() 메서드 사용
String s = new String();
Class c = s.getClass();

2. 클래스 파일 이름을 Class 변수에 직접 대입
Class c = String.Class;

3. Class.forName("클래스 이름") 메서드 사용하기
Class c = Class.forName("java.lang.String");

1번의 경우 getClass() 메서드는 Object에 선언되어 있기 때문에 모든 클래스가 사용할 수 있는 메서드, 이 메서드의 특징은 사용하려면 이미 생성된 인스턴스가 있어야 한다. 2,3번의 경우 컴파일된 클래스 파일이 있다면 클래스 이름만으로 Class 클래스를 가져올 수 있다.

forName() 메서드를 사용할 경우 주의할 점이 있는데 패키지 이름+클래스 이름으로 가져오는 경우 매개변수로 쓰이는 값이 문자열이다. 이 때 매개변수로 받은 문자열에 해당하는 클래스가 없을 경우 ClassNotFoundException 발생한다.

리플렉션이란 사용하려는 클래스의 자료형을 모르는 상태에서 Class 클래스를 활용하여 클래스의 정보를 가져와서 이를 활용해 인스턴스를 생성하거나 메서드를 호출하는 방식을 말한다. Class 클래스와 java.lang.reflect 패키지의 클래스를 사용하면 리플렉션 프로그래밍을 할 수 있다.(클래스의 생성자, 메서드 등 정보를 알 수 있다.) 모든 생성자를 가져오려면 getConstructors(),모든 멤버 변수(필드)를 가져오려면 getFields(), 모든 메서드를 가져오려면 getMethods()를 사용한다.

Class 클래스의 메서드 중 newInstance() 메서드를 사용하면 인스턴스를 생성할 수 있다. 단, 이 메서드는 항상 Object를 반환하므로 생성된 객체형으로 형 변환(다운캐스팅) 필요하다.

Class 클래스를 사용하는 방법은 클래스의 자료형을 직접 사용하는 것보다 더 복잡하고, 예외 처리도 해야 한다.(코드가 복잡해지고 속도도 느려진다.) 따라서 리플렉션 프로그래밍은 컴파일 시점에 알 수 없는 클래스, 즉 프로그램 실행 중에 클래스를 메모리에 로딩하거나 객체가 다른 곳에 위치해서 원격으로 로딩하고 생성할 때 사용해야 한다.

프로그램 실행 이후 클래스의 로딩이 필요한 경우 클래스의 동적 로딩 방식을 사용한다.(자바는 Class.forName() 메서드를 동적 로딩으로 제공하는데 그 이유는 forName() 메서드는 매개변수로 문자열을 입력받기 때문에 입력받는 문자열을 변수로 선언하여 변수 값만 바꾸면 다른 클래스를 로딩할 수 있다. forName() 메서드를 사용하여 Class 클래스를 가져올 때 해당 forName("클래스 이름")의 클래스 이름이 문자열 값이기 때문에 문자열에 오류가 있어도 컴파일할 때 그 오류를 알 수 없다는 점을 항상 유념해야 한다. 클래스 이름과 일치하는 클래스가 없다면 ClassNotFoundException이 발생한다.(동적 로딩 방식은 컴파일할 때 오류를 알 수 없다.) 동적 로딩을 통해 Class 클래스를 가져올 수 있으면 리플렉션 프로그래밍으로 객체를 생성하고 활용할 수 있다.

이번 목차는 갑자기 양이 많아져서 약간 힘들었다. 또 새로운 개념도 많이 등장했다. 나 혼자 코딩!은 평이했고 연습문제는 거의 다 개념과 내용을 확인하는 문제였다.
